<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superposition & Interference Simulation - Hai</title>
    <style>
        :root {
            --primary-color: #3498db; --secondary-color: #2ecc71; --accent-color: #e74c3c;
            --highlight-color: #f1c40f; --text-color: #333; --light-text-color: #555;
            --bg-color: #f4f7f6; --container-bg: #ffffff; --border-color: #dde;
            --panel-bg-color: #f9fbfc; --slider-thumb-color: var(--primary-color);
            --slider-track-color: #cddcda; --button-bg-color: var(--primary-color);
            --button-text-color: #ffffff; --link-color: var(--primary-color);
            --code-bg-color: #e9ecef;
            /* Wave specific colors */
            --wave1-color: rgba(0, 150, 255, 0.7);  /* Light blue, semi-transparent */
            --wave2-color: rgba(46, 204, 113, 0.7); /* Light green, semi-transparent */
            --resultant-wave-color: var(--primary-color); /* Solid primary blue */
            --particle-color-super: var(--accent-color); /* Particles on resultant */
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 10px; background-color: var(--bg-color); color: var(--text-color); line-height: 1.6; }
        .simulation-container { width: 100%; max-width: 900px; /* Slightly wider */ background-color: var(--container-bg); border-radius: 12px; box-shadow: 0 8px 25px rgba(0,0,0,0.08); padding: 20px; box-sizing: border-box; }
        .nav-link-home { display: block; text-align: left; margin-bottom: 15px; font-size: 0.9em; }
        .nav-link-home a { color: var(--link-color); text-decoration: none; font-weight: 500; }
        .nav-link-home a:hover { text-decoration: underline; }
        h1 { color: var(--primary-color); text-align: center; margin-top: 0; margin-bottom: 20px; font-weight: 600; font-size: 1.8em; }

        .controls-wrapper { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }
        .controls-panel {
            flex: 1; min-width: 300px; padding: 15px; background-color: var(--panel-bg-color);
            border: 1px solid var(--border-color); border-radius: 8px;
        }
        .controls-panel h2 { font-size: 1.1em; color: var(--primary-color); margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;}
        .control-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 12px; }
        .control-item { display: flex; align-items: center; gap: 8px; }
        .control-item label { min-width: 90px; font-size: 0.85em; color: var(--light-text-color); white-space: nowrap; }
        input[type="range"] { flex-grow: 1; margin: 0; cursor: pointer; /* Standard slider styles apply */ }
        .control-item span.value-display { min-width: 40px; text-align: right; font-size: 0.8em; background-color: var(--code-bg-color); padding: 3px 6px; border-radius: 4px; font-weight: 500; }

        .global-controls { margin-top:10px; text-align: center; }
        .show-hide-toggles { margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px 15px; font-size: 0.85em;}
        .show-hide-toggles label { cursor: pointer; color: var(--light-text-color);}
        .show-hide-toggles input[type="checkbox"] { margin-right: 4px; vertical-align: middle;}

        .info-panel { text-align: center; margin-bottom: 20px; font-size: 0.9em; background-color: #eef5ff; padding: 10px 12px; border-radius: 6px; border: 1px solid #cde0f5; color: #2c3e50; }
        .info-panel strong { color: var(--primary-color); font-weight: 600; }
        .sim-button { padding: 8px 18px; font-size: 0.9em; font-weight: 500; background-color: var(--button-bg-color); color: var(--button-text-color); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; min-width: 90px; }
        .sim-button:hover { background-color: #2980b9; transform: translateY(-1px); } .sim-button:active { transform: translateY(0px); }
        canvas#superpositionCanvas { border: 1px solid var(--border-color); background-color: #ffffff; display: block; width: 100%; height: 400px; /* Decent height */ border-radius: 8px; touch-action: none; margin-bottom: 20px; }
        /* Notes Section Styles (copied from wave sim, IDs might need to be unique if on same page) */
        .notes-section { width: 100%; margin-top: 15px; margin-bottom: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--panel-bg-color); overflow: hidden; }
        .notes-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; border-bottom: 1px solid var(--border-color); cursor: pointer; background-color: #fdfdfe; }
        .notes-header h3 { margin: 0; font-weight: 600; color: var(--primary-color); font-size: 1em; flex-grow: 1; }
        .notes-header::after { content: '▸'; font-size: 1.2em; transition: transform 0.2s ease-in-out; color: var(--light-text-color); margin-left: 10px; }
        .notes-section.notes-open .notes-header::after { transform: rotate(90deg); }
        .notes-section.notes-open .notes-header { border-bottom-color: transparent; }
        .notes-content { padding: 15px; font-size: 0.9em; display: none; border-top: 1px solid var(--border-color); }
        .notes-section.notes-open .notes-content { display: block; }
        .note-block { margin-bottom: 15px; } .note-block:last-child { margin-bottom: 0; }
        .note-block h4 { margin-top: 0; margin-bottom: 5px; font-weight: 600; color: var(--text-color); }
        .note-block ul { margin-top: 5px; margin-bottom: 10px; padding-left: 25px; }
        .note-block li { margin-bottom: 5px; }
        .note-block code { background-color: var(--code-bg-color); padding: 2px 5px; border-radius: 3px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.95em; color: #333; }
        .note-block p > code, .note-block li > code { display: inline-block; }
        .note-block em { color: var(--light-text-color); font-size: 0.9em; }
        .lang-button { padding: 3px 8px; font-size: 0.75em; background-color: #e9ecef; color: var(--light-text-color); border: 1px solid #ced4da; border-radius: 4px; cursor: pointer; margin-left: 15px; transition: background-color 0.2s, color 0.2s; }
        .lang-button:hover { background-color: #dde; color: var(--text-color); }
        footer { margin-top: 25px; text-align: center; font-size: 0.85em; color: #999; }
        footer a#creatorLink { color: #7f8c8d; font-weight: 500; text-decoration: none; transition: color 0.2s ease; }
        footer a#creatorLink:hover { color: var(--secondary-color); }
         /* Basic Slider styles from previous sims (input[type="range"], ::-webkit-slider-thumb, etc.) */
         input[type="range"] { /* Copied */ flex-grow: 1; margin: 0 8px; cursor: pointer; -webkit-appearance: none; appearance: none; height: 8px; background: var(--slider-track-color); border-radius: 5px; outline: none; }
         input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--slider-thumb-color); border-radius: 50%; cursor: pointer; transition: background-color 0.2s ease-in-out, transform 0.1s ease; }
         input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: var(--slider-thumb-color); border-radius: 50%; border: none; cursor: pointer; transition: background-color 0.2s ease-in-out, transform 0.1s ease; }
         input[type="range"]:hover::-webkit-slider-thumb, input[type="range"]:active::-webkit-slider-thumb { background: #2980b9; transform: scale(1.1); }
         input[type="range"]:hover::-moz-range-thumb, input[type="range"]:active::-moz-range-thumb { background: #2980b9; transform: scale(1.1); }

        @media (max-width: 768px) { .simulation-container { padding: 15px; } h1 { font-size: 1.6em; } .controls-wrapper { flex-direction: column;} .controls-panel { min-width:100%;} canvas#superpositionCanvas {height: 350px;} }
        @media (max-width: 480px) { body { padding: 5px;} h1 {font-size: 1.4em;} .control-item label { min-width: 80px;} canvas#superpositionCanvas {height: 300px;} .info-panel { font-size: 0.85em;}}
    </style>
</head>
<body>
    <div class="simulation-container">
        <div class="nav-link-home">
            <a href="../../waves-vibration.html">← Back to Waves & Vibration Simulations</a>
        </div>
        <h1>Wave Superposition & Interference</h1>

        <div class="controls-wrapper">
            <div class="controls-panel" id="wave1Controls">
                <h2>Wave 1</h2>
                <div class="control-group">
                    <div class="control-item"><label for="amplitude1">Amplitude (A₁):</label><input type="range" id="amplitude1" min="0" max="100" value="40"><span id="amplitude1Value" class="value-display">40</span></div>
                    <div class="control-item"><label for="wavelength1">Wavelength (λ₁):</label><input type="range" id="wavelength1" min="50" max="500" value="200"><span id="wavelength1Value" class="value-display">200</span></div>
                    <div class="control-item"><label for="frequency1">Frequency (f₁):</label><input type="range" id="frequency1" min="0.1" max="2" step="0.1" value="0.5"><span id="frequency1Value" class="value-display">0.5 Hz</span></div>
                    <div class="control-item"><label for="phase1">Initial Phase (φ₁):</label><input type="range" id="phase1" min="0" max="360" step="1" value="0"><span id="phase1Value" class="value-display">0°</span></div>
                </div>
            </div>

            <div class="controls-panel" id="wave2Controls">
                <h2>Wave 2</h2>
                <div class="control-group">
                    <div class="control-item"><label for="amplitude2">Amplitude (A₂):</label><input type="range" id="amplitude2" min="0" max="100" value="40"><span id="amplitude2Value" class="value-display">40</span></div>
                    <div class="control-item"><label for="wavelength2">Wavelength (λ₂):</label><input type="range" id="wavelength2" min="50" max="500" value="200"><span id="wavelength2Value" class="value-display">200</span></div>
                    <div class="control-item"><label for="frequency2">Frequency (f₂):</label><input type="range" id="frequency2" min="0.1" max="2" step="0.1" value="0.5"><span id="frequency2Value" class="value-display">0.5 Hz</span></div>
                    <div class="control-item"><label for="phase2">Initial Phase (φ₂):</label><input type="range" id="phase2" min="0" max="360" step="1" value="0"><span id="phase2Value" class="value-display">0°</span></div>
                </div>
            </div>
        </div>

        <div class="show-hide-toggles">
            <label><input type="checkbox" id="showWave1" checked> Show Wave 1</label>
            <label><input type="checkbox" id="showWave2" checked> Show Wave 2</label>
            <label><input type="checkbox" id="showResultant" checked> Show Resultant</label>
            <label><input type="checkbox" id="showParticles" checked> Show Particles</label>
        </div>

        <div class="info-panel">
            Wave 1 Speed (v₁): <strong id="speed1Value">0 m·s⁻¹</strong> |
            Wave 2 Speed (v₂): <strong id="speed2Value">0 m·s⁻¹</strong>
        </div>

        <canvas id="superpositionCanvas"></canvas>

        <div class="global-controls">
             <button id="pausePlayButtonSuper" class="sim-button">Pause</button>
             <button id="resetTimeButtonSuper" class="sim-button" style="margin-left:10px;">Reset Time</button>
        </div>

        <section id="notesSectionSuper" class="notes-section">
             <div class="notes-header">
                 <h3 data-lang-key="notesTitleSuper">Superposition: Key Concepts</h3>
                 <button id="langToggleButtonSuper" class="lang-button" title="Change notes language">தமிழ்</button>
             </div>
            <div class="notes-content">
                <div class="note-block"> <h4 data-lang-key="superPrincipleTitle">Principle of Superposition</h4> <p data-lang-key="superPrincipleDesc">When two or more waves travel through the same medium at the same time, the resultant displacement of the medium at any point is the algebraic sum of the displacements of the individual waves.</p><code>y_resultant(x,t) = y₁(x,t) + y₂(x,t)</code></div>
                <div class="note-block"> <h4 data-lang-key="interferenceTitle">Interference</h4> <p data-lang-key="interferenceDesc">Interference is the phenomenon that occurs when two waves meet while traveling along the same medium. It results in the formation of a new wave pattern.</p><ul><li data-lang-key="constructiveDesc"><strong>Constructive Interference:</strong> Occurs when waves add up to make a larger amplitude resultant wave (e.g., crest meets crest). This happens when waves are in phase (or phase difference is a multiple of 2π or 360°).</li><li data-lang-key="destructiveDesc"><strong>Destructive Interference:</strong> Occurs when waves add up to make a smaller amplitude (or zero) resultant wave (e.g., crest meets trough). This happens when waves are out of phase (phase difference is an odd multiple of π or 180°).</li></ul></div>
                <div class="note-block"> <h4 data-lang-key="beatsTitle">Beats (f₁ ≈ f₂)</h4> <p data-lang-key="beatsDesc">If two waves of slightly different frequencies interfere, the resultant amplitude varies periodically over time, creating "beats". The beat frequency is <code>f_beat = |f₁ - f₂|</code>.</p></div>
                <div class="note-block"> <h4 data-lang-key="standingTitle">Standing Waves (Conceptual)</h4> <p data-lang-key="standingDesc">If two identical waves (same A, f, λ) travel in opposite directions, they can form a standing wave, which has fixed points of zero amplitude (nodes) and maximum amplitude (antinodes). (This simulation primarily shows co-directional waves).</p></div>
                 <div class="note-block"> <h4 data-lang-key="tipsSuperTitle">Simulation Tips</h4> <ul><li data-lang-key="tipPhaseSuper">Adjust initial phases (φ₁ & φ₂) to observe constructive and destructive interference. Try making them 0° and 180° apart.</li><li data-lang-key="tipFreqSuper">Set frequencies (f₁ & f₂) very close to each other to observe the beat phenomenon (slow amplitude modulation of the resultant wave).</li><li data-lang-key="tipEqualSuper">Set A₁=A₂, f₁=f₂, λ₁=λ₂ and φ₁=0°, φ₂=180° for maximum destructive interference.</li></ul></div>
            </div>
        </section>

    </div>
    <footer> <a id="creatorLink" href="https://www.instagram.com/hai_faizul/" target="_blank">Hai's Superposition Sim</a>. </footer>

    <script>
        // --- Simulation JavaScript ---
        const canvas = document.getElementById('superpositionCanvas');
        const ctx = canvas.getContext('2d');

        // Wave 1 Controls
        const amp1Slider = document.getElementById('amplitude1');
        const lambda1Slider = document.getElementById('wavelength1');
        const freq1Slider = document.getElementById('frequency1');
        const phase1Slider = document.getElementById('phase1');
        const amp1ValSpan = document.getElementById('amplitude1Value');
        const lambda1ValSpan = document.getElementById('wavelength1Value');
        const freq1ValSpan = document.getElementById('frequency1Value');
        const phase1ValSpan = document.getElementById('phase1Value');
        const speed1ValSpan = document.getElementById('speed1Value');

        // Wave 2 Controls
        const amp2Slider = document.getElementById('amplitude2');
        const lambda2Slider = document.getElementById('wavelength2');
        const freq2Slider = document.getElementById('frequency2');
        const phase2Slider = document.getElementById('phase2');
        const amp2ValSpan = document.getElementById('amplitude2Value');
        const lambda2ValSpan = document.getElementById('wavelength2Value');
        const freq2ValSpan = document.getElementById('frequency2Value');
        const phase2ValSpan = document.getElementById('phase2Value');
        const speed2ValSpan = document.getElementById('speed2Value');

        // Global Controls
        const pausePlayBtn = document.getElementById('pausePlayButtonSuper');
        const resetTimeBtn = document.getElementById('resetTimeButtonSuper');
        const showWave1Check = document.getElementById('showWave1');
        const showWave2Check = document.getElementById('showWave2');
        const showResultantCheck = document.getElementById('showResultant');
        const showParticlesCheck = document.getElementById('showParticles');

        // Parameters
        let A1, lambda1, f1, phi1_rad, k1, omega1, v1;
        let A2, lambda2, f2, phi2_rad, k2, omega2, v2;
        let numParticlesSuper = 30; // Default particle number
        let highlightedParticleIndexSuper = -1;
        let particlesSuper = [];

        let timeSuper = 0;
        let isPausedSuper = false;
        let lastTimestampSuper = 0;
        let animationFrameIdSuper = null;

        function updateParametersSuperposition() {
            A1 = parseFloat(amp1Slider.value); lambda1 = parseFloat(lambda1Slider.value); f1 = parseFloat(freq1Slider.value); phi1_rad = parseFloat(phase1Slider.value) * Math.PI / 180;
            amp1ValSpan.textContent = A1.toFixed(0); lambda1ValSpan.textContent = lambda1.toFixed(0); freq1ValSpan.textContent = f1.toFixed(1) + " Hz"; phase1ValSpan.textContent = (phi1_rad * 180 / Math.PI).toFixed(0) + "°";
            k1 = 2 * Math.PI / lambda1; omega1 = 2 * Math.PI * f1; v1 = f1 * lambda1; speed1ValSpan.innerHTML = `${v1.toFixed(1)} m·s<sup>-1</sup>`;

            A2 = parseFloat(amp2Slider.value); lambda2 = parseFloat(lambda2Slider.value); f2 = parseFloat(freq2Slider.value); phi2_rad = parseFloat(phase2Slider.value) * Math.PI / 180;
            amp2ValSpan.textContent = A2.toFixed(0); lambda2ValSpan.textContent = lambda2.toFixed(0); freq2ValSpan.textContent = f2.toFixed(1) + " Hz"; phase2ValSpan.textContent = (phi2_rad * 180 / Math.PI).toFixed(0) + "°";
            k2 = 2 * Math.PI / lambda2; omega2 = 2 * Math.PI * f2; v2 = f2 * lambda2; speed2ValSpan.innerHTML = `${v2.toFixed(1)} m·s<sup>-1</sup>`;

            // Particle setup (can be refined, e.g., based on resultant properties)
            particlesSuper = []; highlightedParticleIndexSuper = -1;
            if (numParticlesSuper > 0 && canvas.width > 0) {
                const particleSpacing = canvas.width / (numParticlesSuper + 1);
                for (let i = 0; i < numParticlesSuper; i++) { particlesSuper.push({ originalX: particleSpacing * (i + 1) }); }
                if (numParticlesSuper > 0) { highlightedParticleIndexSuper = Math.floor((numParticlesSuper -1) / 2); }
            }

            if (isPausedSuper) { drawFrameSuperposition(); }
            else if (!animationFrameIdSuper) { lastTimestampSuper = performance.now(); animationFrameIdSuper = requestAnimationFrame(animateSuperposition); }
        }

        function drawWaveShape(ctx, amplitude, k, omega, phase, time, color, lineDash = [], lineWidth = 1.5) {
            if (amplitude === 0) return;
            ctx.beginPath();
            const y_center = canvas.height / 2;
            ctx.moveTo(0, y_center + amplitude * Math.sin(k * 0 - omega * time + phase));
            for (let x = 1; x <= canvas.width; x++) {
                const y_offset = amplitude * Math.sin(k * x - omega * time + phase);
                ctx.lineTo(x, y_center + y_offset);
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash(lineDash);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawParticlesSuperposition(y_center) {
            if (!showParticlesCheck.checked || particlesSuper.length === 0) return;
            const particleRadius = 4;
            const defaultParticleColor = getComputedStyle(document.documentElement).getPropertyValue('--particle-color-super').trim();
            const highlightParticleColor = getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim();

            // Determine max possible amplitude for dynamic SHM path lines based on current A1, A2
            let maxResultantAmplitude = A1 + A2; // Absolute max possible
            if (maxResultantAmplitude === 0) maxResultantAmplitude = 10; // Avoid zero for paths if both A are 0

            particlesSuper.forEach((particle, index) => {
                const equilibriumX = particle.originalX;
                const y1_val = A1 * Math.sin(k1 * equilibriumX - omega1 * timeSuper + phi1_rad);
                const y2_val = A2 * Math.sin(k2 * equilibriumX - omega2 * timeSuper + phi2_rad);
                const resultant_y_offset = (showWave1Check.checked ? y1_val : 0) + (showWave2Check.checked ? y2_val : 0);

                // Dynamic SHM path based on individual waves or resultant
                let currentMaxOscillation = 0;
                if(showResultantCheck.checked) currentMaxOscillation = maxResultantAmplitude;
                else if(showWave1Check.checked && showWave2Check.checked) currentMaxOscillation = maxResultantAmplitude;
                else if(showWave1Check.checked) currentMaxOscillation = A1;
                else if(showWave2Check.checked) currentMaxOscillation = A2;
                currentMaxOscillation = Math.min(currentMaxOscillation, canvas.height/2 - 10); // Cap visual path


                ctx.beginPath();
                ctx.moveTo(equilibriumX, y_center - currentMaxOscillation);
                ctx.lineTo(equilibriumX, y_center + currentMaxOscillation);
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)'; ctx.setLineDash([2, 3]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);

                ctx.fillStyle = (index === highlightedParticleIndexSuper) ? highlightParticleColor : defaultParticleColor;
                ctx.beginPath(); ctx.arc(equilibriumX, y_center + resultant_y_offset, particleRadius, 0, 2 * Math.PI); ctx.fill();
            });
        }


        function drawFrameSuperposition() {
            if (!ctx || !canvas) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const y_center = canvas.height / 2;

            // Draw Equilibrium Line
            ctx.beginPath(); ctx.moveTo(0, y_center); ctx.lineTo(canvas.width, y_center);
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)'; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);

            let resultantMaxAmpForPaths = 0; // Used for particle SHM path calculation

            // Draw Wave 1
            if (showWave1Check.checked) {
                drawWaveShape(ctx, A1, k1, omega1, phi1_rad, timeSuper, getComputedStyle(document.documentElement).getPropertyValue('--wave1-color').trim(), [5, 5]);
                resultantMaxAmpForPaths += A1;
            }
            // Draw Wave 2
            if (showWave2Check.checked) {
                drawWaveShape(ctx, A2, k2, omega2, phi2_rad, timeSuper, getComputedStyle(document.documentElement).getPropertyValue('--wave2-color').trim(), [3, 3]);
                 resultantMaxAmpForPaths += A2;
            }

            // Draw Resultant Wave (if toggled and at least one wave is shown)
            if (showResultantCheck.checked && (showWave1Check.checked || showWave2Check.checked)) {
                ctx.beginPath();
                ctx.moveTo(0, y_center +
                    (showWave1Check.checked ? A1 * Math.sin(k1 * 0 - omega1 * timeSuper + phi1_rad) : 0) +
                    (showWave2Check.checked ? A2 * Math.sin(k2 * 0 - omega2 * timeSuper + phi2_rad) : 0)
                );
                for (let x = 1; x <= canvas.width; x++) {
                    const y1 = showWave1Check.checked ? (A1 * Math.sin(k1 * x - omega1 * timeSuper + phi1_rad)) : 0;
                    const y2 = showWave2Check.checked ? (A2 * Math.sin(k2 * x - omega2 * timeSuper + phi2_rad)) : 0;
                    ctx.lineTo(x, y_center + y1 + y2);
                }
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--resultant-wave-color').trim();
                ctx.lineWidth = 2; // Make resultant wave prominent
                ctx.stroke();
            }

            drawParticlesSuperposition(y_center);
        }

        function animateSuperposition(timestamp) {
            if (!isPausedSuper) {
                if (!lastTimestampSuper) lastTimestampSuper = timestamp;
                const deltaTime = (timestamp - lastTimestampSuper) / 1000;
                lastTimestampSuper = timestamp;
                if (!isNaN(deltaTime) && deltaTime > 0 && deltaTime < 0.5) timeSuper += deltaTime;
            }
            drawFrameSuperposition();
            if (!isPausedSuper) animationFrameIdSuper = requestAnimationFrame(animateSuperposition);
            else { if (animationFrameIdSuper) cancelAnimationFrame(animationFrameIdSuper); animationFrameIdSuper = null; }
        }

        // Event Listeners
        [amp1Slider, lambda1Slider, freq1Slider, phase1Slider, amp2Slider, lambda2Slider, freq2Slider, phase2Slider].forEach(slider => {
            slider.addEventListener('input', updateParametersSuperposition);
        });
        [showWave1Check, showWave2Check, showResultantCheck, showParticlesCheck].forEach(check => {
            check.addEventListener('change', () => {
                if(isPausedSuper) drawFrameSuperposition(); // Redraw if paused when toggles change
                 // No need to call updateParameters unless toggles affect underlying physics array setup.
                 // If particles depended on resultant's calculated max for setup, then call updateParameters.
            });
        });

        pausePlayBtn.addEventListener('click', () => {
            isPausedSuper = !isPausedSuper;
            pausePlayBtn.textContent = isPausedSuper ? 'Play' : 'Pause';
            if (!isPausedSuper) {
                lastTimestampSuper = performance.now();
                if (!animationFrameIdSuper) animationFrameIdSuper = requestAnimationFrame(animateSuperposition);
            } else {
                if (animationFrameIdSuper) cancelAnimationFrame(animationFrameIdSuper);
                animationFrameIdSuper = null;
            }
        });
        resetTimeBtn.addEventListener('click', () => {
            timeSuper = 0;
            // updateParametersSuperposition(); // Will be called by initial if needed or by pause/play logic
            if (isPausedSuper) drawFrameSuperposition(); // Redraw immediately
            else { // If running, ensure timestamps are reset
                lastTimestampSuper = performance.now();
                if (!animationFrameIdSuper) animationFrameIdSuper = requestAnimationFrame(animateSuperposition);
            }
        });

        // Language Toggle
        const langToggleButtonSuper = document.getElementById('langToggleButtonSuper');
        let currentNotesLanguageSuper = 'en';
        const languageDataSuper = {
            notesTitleSuper: { en: "Superposition: Key Concepts", ta: "மேற்பொருந்துதல்: முக்கிய கருத்துகள்" },
            superPrincipleTitle: {en: "Principle of Superposition", ta: "மேற்பொருந்துதல் தத்துவம்"},
            superPrincipleDesc: {en: "When two or more waves travel through the same medium at the same time, the resultant displacement of the medium at any point is the algebraic sum of the displacements of the individual waves.<br><code>y_resultant(x,t) = y₁(x,t) + y₂(x,t)</code>", ta: "ஒரே நேரத்தில் இரண்டு அல்லது அதற்கு மேற்பட்ட அலைகள் ஒரே ஊடகத்தின் வழியே பயணிக்கும்போது, எந்தவொரு புள்ளியிலும் ஊடகத்தின் விளைவான இடப்பெயர்ச்சி என்பது தனிப்பட்ட அலைகளின் இடப்பெயர்ச்சிகளின் இயற்கணித கூட்டுத்தொகையாகும்.<br><code>y_விளைவு(x,t) = y₁(x,t) + y₂(x,t)</code>"},
            interferenceTitle: {en: "Interference", ta: "குறுக்கீட்டு விளைவு"},
            interferenceDesc: {en: "Interference is the phenomenon that occurs when two waves meet while traveling along the same medium. It results in the formation of a new wave pattern.", ta: "குறுக்கீட்டு விளைவு என்பது ஒரே ஊடகத்தில் பயணிக்கும் இரண்டு அலைகள் சந்திக்கும்போது ஏற்படும் நிகழ்வு. இது ஒரு புதிய அலை வடிவத்தை உருவாக்குகிறது."},
            constructiveDesc: {en: "<strong>Constructive Interference:</strong> Occurs when waves add up to make a larger amplitude resultant wave (e.g., crest meets crest). This happens when waves are in phase (or phase difference is a multiple of 2π or 360°).", ta: "<strong>ஆக்கக் குறுக்கீடு:</strong> அலைகள் கூடி ஒரு பெரிய வீச்சுடைய விளைவு அலையை உருவாக்கும்போது ஏற்படுகிறது (எ.கா., முகடு முகடுடன் встречается). அலைகள் ஒரே கட்டத்தில் இருக்கும்போது (அல்லது கட்ட வேறுபாடு 2π அல்லது 360° இன் மடங்காக இருக்கும்போது) இது நிகழ்கிறது."},
            destructiveDesc: {en: "<strong>Destructive Interference:</strong> Occurs when waves add up to make a smaller amplitude (or zero) resultant wave (e.g., crest meets trough). This happens when waves are out of phase (phase difference is an odd multiple of π or 180°).", ta: "<strong>அழிவுக் குறுக்கீடு:</strong> அலைகள் கூடி ஒரு சிறிய வீச்சு (அல்லது பூஜ்ஜியம்) கொண்ட விளைவு அலையை உருவாக்கும்போது ஏற்படுகிறது (எ.கா., முகடு அகடுடன் встречается). அலைகள் கட்டத்திற்கு வெளியே இருக்கும்போது (கட்ட வேறுபாடு π அல்லது 180° இன் ஒற்றைப்படை மடங்காக இருக்கும்போது) இது நிகழ்கிறது."},
            beatsTitle: {en: "Beats (f₁ ≈ f₂)", ta: "விம்மல்கள் (f₁ ≈ f₂)"},
            beatsDesc: {en: "If two waves of slightly different frequencies interfere, the resultant amplitude varies periodically over time, creating \"beats\". The beat frequency is <code>f_beat = |f₁ - f₂|</code>.", ta: "சற்று மாறுபட்ட அதிர்வெண்கள் கொண்ட இரண்டு அலைகள் குறுக்கிட்டால், விளைவான வீச்சு காலப்போக்கில் குறிப்பிட்ட கால இடைவெளியில் மாறுபட்டு, \"விம்மல்களை\" உருவாக்குகிறது. விம்மல் அதிர்வெண் <code>f_விம்மல் = |f₁ - f₂|</code>."},
            standingTitle: {en: "Standing Waves (Conceptual)", ta: "நிலை அலைகள் (கருத்து)"},
            standingDesc: {en: "If two identical waves (same A, f, λ) travel in opposite directions, they can form a standing wave, which has fixed points of zero amplitude (nodes) and maximum amplitude (antinodes). (This simulation primarily shows co-directional waves).", ta: "ஒரே மாதிரியான இரண்டு அலைகள் (ஒரே A, f, λ) எதிர் திசைகளில் பயணித்தால், அவை ஒரு நிலை அலையை உருவாக்கலாம், இது பூஜ்ஜிய வீச்சின் நிலையான புள்ளிகளையும் (கணுக்கள்) மற்றும் அதிகபட்ச வீச்சின் புள்ளிகளையும் (எதிர் கணுக்கள்) கொண்டிருக்கும். (இந்த உருவகப்படுத்துதல் முக்கியமாக ஒரே திசையில் செல்லும் அலைகளைக் காட்டுகிறது)."},
            tipsSuperTitle: {en: "Simulation Tips", ta: "உருவகப்படுத்துதல் குறிப்புகள்"},
            tipPhaseSuper: {en: "Adjust initial phases (φ₁ & φ₂) to observe constructive and destructive interference. Try making them 0° and 180° apart.", ta: "ஆக்க மற்றும் அழிவு குறுக்கீட்டை கவனிக்க தொடக்க கட்டங்களை (φ₁ & φ₂) சரிசெய்யவும். அவற்றை 0° மற்றும் 180° இடைவெளியில் அமைக்கவும்."},
            tipFreqSuper: {en: "Set frequencies (f₁ & f₂) very close to each other to observe the beat phenomenon (slow amplitude modulation of the resultant wave).", ta: "விம்மல் நிகழ்வை (விளைவு அலையின் மெதுவான வீச்சு பண்பேற்றம்) கவனிக்க அதிர்வெண்களை (f₁ & f₂) மிக நெருக்கமாக அமைக்கவும்."},
            tipEqualSuper: {en: "Set A₁=A₂, f₁=f₂, λ₁=λ₂ and φ₁=0°, φ₂=180° for maximum destructive interference.", ta: "அதிகபட்ச அழிவு குறுக்கீட்டிற்கு A₁=A₂, f₁=f₂, λ₁=λ₂ மற்றும் φ₁=0°, φ₂=180° என அமைக்கவும்."}
        };
        function updateNotesLanguageSuper(lang) { document.querySelectorAll('[data-lang-key]').forEach(element => { const key = element.getAttribute('data-lang-key'); if (languageDataSuper[key] && languageDataSuper[key][lang]) { element.innerHTML = languageDataSuper[key][lang]; } }); langToggleButtonSuper.textContent = lang === 'en' ? 'தமிழ்' : 'English';}
        langToggleButtonSuper.addEventListener('click', (event) => { event.stopPropagation(); currentNotesLanguageSuper = (currentNotesLanguageSuper === 'en') ? 'ta' : 'en'; updateNotesLanguageSuper(currentNotesLanguageSuper);});

        // Initial Setup
        function resizeCanvasSuper() {
            canvas.width = canvas.offsetWidth;
            canvas.height = 400; // Maintain fixed height
            updateParametersSuperposition(); // Re-calc particle positions, etc.
        }
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvasSuper(); // Call initial resize
            window.addEventListener('resize', resizeCanvasSuper); // Add resize listener

            updateNotesLanguageSuper(currentNotesLanguageSuper);
            const notesSection = document.getElementById('notesSectionSuper');
            const notesHeader = notesSection.querySelector('.notes-header');
            if (notesHeader && notesSection) { notesHeader.addEventListener('click', (event) => { if (event.target !== langToggleButtonSuper && !langToggleButtonSuper.contains(event.target)) { notesSection.classList.toggle('notes-open'); } }); }

             if (!isPausedSuper) {
                 lastTimestampSuper = performance.now();
                 animationFrameIdSuper = requestAnimationFrame(animateSuperposition);
             } else {
                 drawFrameSuperposition();
             }
        });
    </script>
</body>
</html>
